# server.py (Interactive Inputs, with HMAC-MD5 Mitigation)
import hashlib
import hmac # Import the hmac module

# Global variable for SECRET_KEY to be set by input
SECRET_KEY_GLOBAL = b''

def get_secret_key_from_input():
    """Gets the secret key from user input and sets it globally."""
    global SECRET_KEY_GLOBAL
    while True:
        key_str = input("Enter the SECRET_KEY for the server: ")
        if key_str:
            SECRET_KEY_GLOBAL = key_str.encode('utf-8') # Encode to bytes
            print(f"Server will use SECRET_KEY: {SECRET_KEY_GLOBAL.decode()} (length: {len(SECRET_KEY_GLOBAL)})")
            break
        else:
            print("SECRET_KEY cannot be empty. Please enter a value.")

def generate_mac(message: bytes) -> str:
    """
    Generates a MAC using HMAC-MD5.
    This is secure against length extension attacks.
    """
    if not SECRET_KEY_GLOBAL:
        raise ValueError("SECRET_KEY is not set. Run get_secret_key_from_input() first.")
    
    # Create an HMAC object: hmac.new(key, message, digestmod)
    # key: The secret key (bytes)
    # message: The message to hash (bytes)
    # digestmod: The hash algorithm to use (e.g., hashlib.md5)
    h = hmac.new(SECRET_KEY_GLOBAL, message, hashlib.md5)
    return h.hexdigest() # Return the MAC as a hex string

def verify(message: bytes, mac: str) -> bool:
    """Verifies if the given HMAC-MD5 MAC is valid for the message."""
    expected_mac = generate_mac(message)
    print(f"    Inside verify (HMAC) - Expected MAC: {expected_mac}, Received MAC: {mac}")
    return hmac.compare_digest(expected_mac, mac) # Use hmac.compare_digest for secure comparison

def main():
    print("--- Secure Server (HMAC-MD5) Setup ---")
    get_secret_key_from_input()

    original_message_str = input("Enter the original message string (e.g., amount=100&to=alice): ")
    original_message_bytes = original_message_str.encode('utf-8')

    original_mac = generate_mac(original_message_bytes)

    print("\n=== Secure Server Initial Output (for client.py test) ===")
    print(f"Using SECRET_KEY: {SECRET_KEY_GLOBAL.decode()} (length: {len(SECRET_KEY_GLOBAL)})")
    print(f"Original message: {original_message_bytes.decode()}")
    print(f"Generated Original HMAC-MD5 MAC: {original_mac} <--- Attacker: Note this MAC and Secret Key Length")

    print("\n--- Verifying legitimate message (self-check) ---")
    if verify(original_message_bytes, original_mac):
        print("Legitimate HMAC-MD5 MAC verified successfully. Message is authentic.\n")
    else:
        print("Error: Legitimate HMAC-MD5 MAC verification failed (unexpected).\n")

    # --- Section to test the attacker's (length-extended) forged message ---
    print("\n--- Secure Server: Awaiting Attacker's Forged Message and MAC (from client.py) ---")
    print("You will now input the forged data generated by client.py, which was targeting the OLD insecure MAC.")
    
    while True:
        forged_message_hex_str = input("Enter the Forged Message for Server (as HEX string from client.py output): ")
        try:
            attacker_forged_message_bytes = bytes.fromhex(forged_message_hex_str)
            break
        except ValueError:
            print("Invalid hex string. Please ensure you copy the hex representation correctly.")

    attacker_forged_mac_hex = input("Enter the Forged MAC (hex string from client.py output): ")

    print("\n--- Verifying Attacker's Forged Message (generated by client.py for the old vulnerable MAC) ---")
    print(f"Attempting to verify forged message (bytes, from hex): {attacker_forged_message_bytes}")
    print(f"With forged MAC: {attacker_forged_mac_hex}")

    if verify(attacker_forged_message_bytes, attacker_forged_mac_hex):
        print("\n>>> VULNERABILITY STILL PRESENT?: Server accepted the attacker's old forged message and MAC (UNEXPECTED for HMAC!).")
    else:
        print("\n>>> ATTACK MITIGATED: Server rejected the attacker's old forged message and MAC (as expected with HMAC).")

if __name__ == "__main__":
    main()
